{% load static %}

<!-- Combined MPesa + Crypto Payment Modal Component -->
<div style="margin:16px 0;">
  <button id="open-payment-demo" class="btn-primary">Open Payment Modal (demo)</button>
</div>

<div id="payment-modal" class="payment-modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="payment-modal-content">
    <button id="payment-close" class="close-btn" aria-label="Close">×</button>

    <div class="payment-header">
      <div id="selected-coin-image"></div>
      <h2 id="selected-coin-name">Buy</h2>
    </div>

    <p class="price">Price (USD): <span id="selected-coin-price">-</span></p>
    <p class="price">Price (KES): <span id="selected-coin-price-kes">-</span></p>

    <!-- PAYMENT METHOD SWITCHER -->
    <div class="payment-method-tabs">
      <button class="tab-btn active" data-tab="mpesa">Pay with MPesa</button>
      <button class="tab-btn" data-tab="crypto">Pay with Crypto</button>
    </div>

    <!-- MPESA SECTION -->
    <div id="tab-mpesa" class="tab-section active">
      <div class="form-field">
        <label for="mpesa-phone">Phone Number (e.g. 0712345678)</label>
        <input id="mpesa-phone" type="text" class="form-control">
      </div>

      <div class="form-field">
        <label for="mpesa-amount">Amount (KES)</label>
        <input id="mpesa-amount" type="number" class="form-control" readonly>
      </div>

      <button id="mpesa-pay" class="btn-primary">Pay with MPesa</button>
      <div id="mpesa-status" class="status"></div>
    </div>

    <!-- CRYPTO SECTION -->
    <div id="tab-crypto" class="tab-section">
      <div class="wallet-section">
        <label for="wallet-address">Wallet Address</label>
        <div class="wallet-row">
          <input type="text" id="wallet-address" readonly aria-label="Wallet address">
          <button id="copy-wallet" class="copy-btn" aria-label="Copy wallet address">Copy</button>
        </div>
      </div>

      <div class="qr-wrapper">
        <canvas id="qr-code"></canvas>
      </div>
    </div>

  </div>
</div>

<script>
(async function(){
  const modal = document.getElementById('payment-modal');
  const openDemo = document.getElementById('open-payment-demo');
  const closeBtn = document.getElementById('payment-close');

  const tabBtns = Array.from(document.querySelectorAll('.tab-btn'));
  const mpesaTab = document.getElementById('tab-mpesa');
  const cryptoTab = document.getElementById('tab-crypto');

  const selName = document.getElementById('selected-coin-name');
  const selImage = document.getElementById('selected-coin-image');
  const selPriceUSD = document.getElementById('selected-coin-price');
  const selPriceKES = document.getElementById('selected-coin-price-kes');

  const walletInput = document.getElementById('wallet-address');
  const copyBtn = document.getElementById('copy-wallet');
  const qrCanvas = document.getElementById('qr-code');

  const mpesaPhone = document.getElementById('mpesa-phone');
  const mpesaAmount = document.getElementById('mpesa-amount');
  const mpesaPay = document.getElementById('mpesa-pay');
  const mpesaStatus = document.getElementById('mpesa-status');

  let pollingInterval;

  function openModal(){ modal.classList.add('open'); modal.setAttribute('aria-hidden','false'); }
  function closeModal(){ modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); }

  closeBtn?.addEventListener('click', closeModal);
  modal?.addEventListener('click', e=>{ if(e.target===modal) closeModal(); });

  tabBtns.forEach(btn=>{
    btn.addEventListener('click', function(){
      tabBtns.forEach(b=>b.classList.remove('active'));
      this.classList.add('active');
      if(this.dataset.tab==='crypto'){
        mpesaTab.classList.remove('active');
        cryptoTab.classList.add('active');
      } else {
        cryptoTab.classList.remove('active');
        mpesaTab.classList.add('active');
      }
    });
  });

  async function fetchCryptoPrices() {
    try {
      const coins = [{id:"bitcoin", symbol:"BTC"},{id:"ethereum",symbol:"ETH"},{id:"dogecoin",symbol:"DOGE"}];
      let prices = {};
      for(const coin of coins){
        const res = await fetch(`https://api.coinbase.com/v2/prices/${coin.symbol}-USD/spot`);
        const data = await res.json();
        prices[coin.id] = parseFloat(data.data.amount);
      }
      return prices;
    } catch(err){ console.error("Crypto price fetch error:", err); return null; }
  }

  async function fetchForexRate() {
    try {
      const res = await fetch("https://api.exchangerate.host/latest?base=USD&symbols=KES");
      const data = await res.json();
      if(data?.success && data.rates && typeof data.rates.KES==='number') return data.rates.KES;
      console.warn("Unexpected forex API response structure:", data);
      return null;
    } catch(err){ console.error("Forex fetch error:", err); return null; }
  }

  async function populate(card){
    const name = card.dataset?.coin || card.getAttribute?.('data-coin') || '';
    const image = card.querySelector?.('img')?.src || card.dataset?.image || '';
    const wallet = card.dataset?.wallet || card.getAttribute?.('data-wallet') || '';
    selName.textContent = name || 'Buy';
    selImage.innerHTML = image?`<img src="${image}" width="60" alt="${name||'coin'}"/>`:'';
    walletInput.value = wallet || '';

    const cryptoPrices = await fetchCryptoPrices();
    let rateKES = await fetchForexRate();
    if(!rateKES || rateKES <= 0) rateKES = 150; // fallback 1 USD ~ 150 KES

    if(cryptoPrices && cryptoPrices[name.toLowerCase()]){
      const usdPrice = cryptoPrices[name.toLowerCase()];
      selPriceUSD.textContent = usdPrice.toFixed(2);
      selPriceKES.textContent = Math.round(usdPrice*rateKES).toLocaleString();
      if(mpesaAmount) mpesaAmount.value = Math.max(1, Math.round(usdPrice*rateKES)); // ensure >0
    } else {
      console.warn(`No crypto price found for ${name}`);
      if(mpesaAmount) mpesaAmount.value = 1;
    }

    try{
      if(typeof QRCode!=='undefined' && qrCanvas) QRCode.toCanvas(qrCanvas, wallet||'', {margin:2});
      else if(typeof QR!=='undefined' && qrCanvas && typeof QR.toCanvas==='function') QR.toCanvas(qrCanvas, wallet||'');
    }catch(err){ console.error('QR gen failed', err); qrCanvas?.getContext?.('2d')?.clearRect(0,0,qrCanvas.width,qrCanvas.height); }

    openModal();
  }

  async function recalcMpesaAmount(coinName){
    const cryptoPrices = await fetchCryptoPrices();
    let rateKES = await fetchForexRate();
    if(!rateKES || rateKES <= 0) rateKES = 150;
    if(cryptoPrices && cryptoPrices[coinName.toLowerCase()]){
      const usdPrice = cryptoPrices[coinName.toLowerCase()];
      selPriceUSD.textContent = usdPrice.toFixed(2);
      selPriceKES.textContent = Math.round(usdPrice*rateKES).toLocaleString();
      if(mpesaAmount) mpesaAmount.value = Math.max(1, Math.round(usdPrice*rateKES));
    }
  }

  const cards = document.querySelectorAll('.coin, .crypto-card, [data-coin]');
  cards.forEach(card=>{
    card.addEventListener('click', async ()=>{
      await populate(card);
      const name = card.dataset?.coin || card.getAttribute?.('data-coin') || '';
      if(name) recalcMpesaAmount(name);
    });
  });
  openDemo?.addEventListener('click', async ()=>{
    await populate(document.createElement('div'));
  });

  // Listen for global coinSelected events dispatched by index.js (dynamic cards)
  window.addEventListener('coinSelected', async (e) => {
    try {
      const coin = e && e.detail ? e.detail : null;
      if(!coin) return;
      // Create a lightweight element with dataset the populate() function expects
      const temp = document.createElement('div');
      temp.dataset.coin = coin.name || coin.id || '';
      temp.dataset.image = coin.image || '';
      temp.dataset.wallet = coin.wallet || '';
      await populate(temp);
      if(coin.name) recalcMpesaAmount(coin.name);
    } catch(err){ console.error('coinSelected handler failed', err); }
  });

  copyBtn?.addEventListener('click', ()=>{
    if(!walletInput) return;
    walletInput.select();
    try{ document.execCommand('copy'); copyBtn.textContent='Copied!'; setTimeout(()=>{copyBtn.textContent='Copy';},1200); }catch(e){console.error('copy failed', e);}
  });

  async function checkMpesaStatus(paymentId){
    try {
      const res = await fetch(`/payments/status/${paymentId}/`);
      const data = await res.json();
      if(data?.status==='SUCCESS'){
        mpesaStatus.textContent = '✅ Payment confirmed!';
        clearInterval(pollingInterval);
        setTimeout(()=>{location.reload();}, 2000);
      } else if(data?.status==='FAILED'){
        mpesaStatus.textContent = '❌ Payment failed.';
        clearInterval(pollingInterval);
      } else {
        mpesaStatus.textContent = 'Awaiting confirmation on your phone…';
      }
    } catch(e){
      console.error('Status check failed', e);
      mpesaStatus.textContent = 'Error checking payment status…';
    }
  }

  mpesaPay?.addEventListener('click', async ()=>{
    if(!mpesaPhone || !mpesaAmount){ mpesaStatus.textContent='Phone and amount required.'; return; }
    const phone=mpesaPhone.value.trim();
    const amount=mpesaAmount.value.trim();
    if(!phone || !amount || parseInt(amount)<=0){
      mpesaStatus.textContent='Invalid amount or phone.';
      return;
    }

    mpesaStatus.textContent='Sending STK Push...';
    try{
      const resp = await fetch('/payments/initiate/',{
        method:'POST',
        headers:{'Content-Type':'application/json','X-CSRFToken':(function(){var re=/(^|; )csrftoken=([^;]+)/;var m=document.cookie.match(re);return m?decodeURIComponent(m[2]):'';})()},
        body:JSON.stringify({phone_number:phone, amount:amount})
      });
      const result = await resp.json();
      if(!result?.success){
        mpesaStatus.textContent='Error: '+(result?.message||result?.error||'Unknown');
        return;
      }
      mpesaStatus.textContent='Awaiting confirmation on your phone…';
      const paymentId = result.payment_id; // backend must return this

      pollingInterval = setInterval(()=>checkMpesaStatus(paymentId), 3000);

    }catch(err){
      console.error(err);
      mpesaStatus.textContent='Network error initiating payment.';
    }
  });

})();
</script>
